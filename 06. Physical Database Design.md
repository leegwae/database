 # 06. Physical Database Design

- 물리적 설계 단계에서는 논리적인 설계의 데이터 구조를 보조 기억 장치 상의 화일(물리적 인데이터 모델)로 사상한다.
- 예상 빈도를 포함하여 데이터베이스 질의와 트랜잭션을 분석한다.
- 데이터에 대한 효율적인 접근을 제공하기 위해 저장 구조와 접근 방법들을 다룬다.
- 특정 DBMS의 특성을 고려하여 진행된다.
- 질의를 효율적으로 지원하기 위해서  인덱스 구조를 적절히 사용한다.



## 6.1 보조 기억 장치

- 사용자가 데이터를 질의하면, DBMS는 디스크 상의 데이터베이스로부터 사용자가 원하는 데이터를 포함하고 있는 디스크 블록을 주기억 장치에 적재한다.

- 데이터가 변경된 경우 블록들을 디스크에 다시 기록한다.

- 블록 크기는 운영 체제에 따라 다르며, 512바이트부터 시작한다,

  - 보통 블록 크기는 4096바이트(8K 바이트)이다.

- 각 화일은 고정된 크기의 블록들로 나누어져서 저장된다.

- 디스크는 데이터베이스를 장기간 보관하는 주된 보조 기억장치이다.

- 저장 장치의 계층 구조는 주기억 장치 - 디스크 - 테이프 순이다.

  

<img src="C:\Users\jy\repos\database\image\6.1 저장 장치의 계층 구조.PNG" alt="6.1 저장 장치의 계층 구조" style="zoom:40%;" />

### 6.1.1 자기 디스크

- 디스크는 자기 물질로 만들어진 여러 개의 판으로 이루어진다.
- 각 판의 면마다 디스크 헤드가 있다.
- 각 판은 **트랙**과 **섹터**로 구분된다.
- 정보는 디스크 표면 상의 트랙을 따라 저장된다.
- 실린더는 여러 개의 디스크 면 중에서 같은 지름을 갖는 트랙들의 모임이다.
- 블록은 한 개 이상의 섹터로 이루어진다.
- 디스크에서 임의의 블록을 읽어오거나 기록하는데 걸리는 시간은 다음과 같다.
  - 탐구 시간(seek time)
  - 회전 지연 시간(rotational delay)
  - 전송 시간(transfer time)



## 6.2 버퍼 관리와 운영 체제

- 디스크 입출력을 컴퓨터 시스템에서 가장 속도가 느린 작업이다. 따라서 DBMS의 성능을 향상시키려면 입출력 횟수를 줄여야 한다.
  - 가능한 한 많은 블록을 주기억 장치에 유지하거나, 자주 참조되는 블록을 주기억 장치에 유지하여 블록 전송 횟수를 줄일 수 있다.
- **버퍼**는 디스크 블록들을 저장하는데 사용되는 주기억 장치 공간이다.
- **버퍼 관리자**는 운영 체제의 구성 요소로서 주기억 장치 내에서 버퍼 공간을 할당하고 관리하는 일을 맡는다.
- 운영 체제에서 버퍼 관리를 위해 흔히 사용되는 LRU 알고리즘은 데이터베이스에서는 항상 우수한 성능을 보이지 않는다.



## 6.3 디스크 상에서 화일의 레코드 배치

- 릴레이션의 **애트리뷰트**는 고정 또는 가변 길이의 **필드**로 표현된다.
- 연관된 애트리뷰트, 즉 연관된 필드들이 모여서 고정 또는 가변 길이의 **레코드**가 된다.
- 하나의 릴레이션을 구성하는 레코드들의 모임은 **블록**에 저장된다.
- **화일**은 블록들의 모임이다.

<img src="C:\Users\jy\repos\database\image\6.4 화일과 블록과 레코드.PNG" alt="6.4 화일과 블록과 레코드" style="zoom:40%;" />



- 한 화일에 속하는 블록들이 반드시 인접할 필요는 없다.
- 인접한 블록들을 읽는 경우 탐구 시간과 회전 지연 시간이 들지 않아 입출력 속도가 빠르다. 그래서 블록들이 인접하도록 한 화일의 블록들을 재조직한다.



### 6.3.1 BLOB(Binary Large Object)

**BLOB(Binary Large Object)**는 이미지(GIF, JPG), 동영상(MPEG, AVI) 등 대규모 크기의 데이터를 저장하는데 사용한다.

- MS SQL Server에서 BLOB의 최대 크기는 2GB까지도 가능하다.



### 6.3.2 채우기 인수

**채우기 인수(fill factor)**는 각 블록에서 레코드로 채워진 공간의 비율을 뜻한다.

- 블록에 레코드를 꽉 채우지 않고 빈 공간을 남겨두는 이유는, 레코드가 삽입될 때 기존의 레코드들을 이동하는 가능성을 줄이기 위해서이다.



### 6.3.3 고정 길이 레코드

고정 길이 레코드에서 레코드의 길이가 `n`바이트라고 하자. 레코드 `i`에 접근하려면 `n*(i-1)+1`의 위치(레코드 `i`의 시작 위치)부터 레코드를 `n`바이트 읽는다.



### 6.3.4 화일 내의 클러스터링

**한 화일 내의 클러스터링(intra-file clustering)**은 한 화일 내에서 함께 검색될 가능성이 높은 레코드들을 디스크 상에서 물리적으로 가까운 곳에 모아두는 것이다.



## 6.4 화일 조직

**화일 조직**은 화일 내의 데이터를 보조 기억 장치에서 블록과 레코드들로 배치하는 것이다. 화일 조직에는 전형적으로 다음 유형이 있다.

- (1) 히프 파일(heap file)
- (2) 순차 화일(sequential file)
- (3) 인덱스된 순차 화일(indexed sequential file)
- (4) 직접 화일(hash file)

이중 히프 화일, 순차 화일은 성능이 좋지 않아 DBMS에서는 사용이 불가하다. 순차 화일에 한 개 이상의 인덱스를 추가한 인덱스된 순차 화일이 DBMS에서 가장 많이 사용하는 화일 조직이다.



### 6.4.1 히프 화일

**히프 화일**은 가장 단순한 화일 조직이다.

- 일반적으로 레코드들이 삽입된 순서대로 화일에 저장된다. 레코드에는 순서가 없다.
- 삽입: 새로 삽입되는 레코드는 화일의 가장 끝에 첨부된다.
- 검색: 원하는 레코드를 찾기 위하여 모든 레코드들을 순차적으로 접근해야 한다.
- 삭제: 원하는 레코드를 찾은 후 해당 레코드를 삭제하고, 삭제된 레코드가 차지하던 공간은 재사용하지 않는다.
- 빈 공간이 넓을수록 성능이 좋지 않으므로, 히프 화일을 주기적으로 재조직해야 한다.



#### 6.4.1.1 히프 화일의 성능

```sql
SELECT * FROM CHAMPION;
```

- 모든 레코드를 참조하고, 레코드들에 접근하는 순서가 중요하지 않다면 효율적이다.

```sql
SELECT CHAMPNAME FROM CHAMPION WHERE CHAMPNO = 130;
```

- 특정 레코드를 검색하는 경우는 비효율적이다.
  - 히프 화일에 `b`개의 블록이 있다면 원하는 블록을 찾기 위해 평균적으로 `b/2`개의 블록을 읽어야 한다.

```sql
SELECT CHAMPNAME, CHAMPNO FROM CHAMPION WHERE CHAMPNO = 3;
```

- 몇 개의 레코드들을 검색하는 경우에도 비효율적이다.
- 조건에 맞는 레코드를 한 개 이상 찾았더라도 화일의 마지막 블록까지 읽어서 조건에 부합하는 레코드가 있는지 확인해야한다. 즉 `b`개의 블록을 모두 읽어야 한다.

```sql
SELECT CHAMPNAME, CHAMPNO FROM CHAMPION WHERE CHAMPNO >= 3;
```

- 위 질의도 릴레이션의 모든 레코드들에 접근해야 한다.



#### 6.4.1.2 히프 화일과 연산

- 삽입: 마지막 블록의 레코드를 가리키게 저장하면 되므로 효율적이다.
- 삭제, 탐색, 순차 탐색, 특정 레코드 검색: 시간이 많이 소요된다.

예)

- 화일에 레코드가 10000000개 있다.
- 레코드의 길이는 200바이트이다.
- 블록 크기는 4096 바이트이다.
- 블로킹 인수는 4096/200 = 20이다.
  - 블로킹 인수(blocking factor)는 한 블록에 포함되는 레코드 수를 뜻한다.
- 화일에 필요한 블록 수는 10000000/20 = 500000이다.
- 특정 레코드를 찾으려면 평균적으로 500000/2 = 250000개의 디스크 블록을 읽어야한다.
- 하나의 블록을 읽는 10ms가 걸리면 250000 * 10ms = 2500000ms = 2500초 = 42분이 소요된다.



### 6.4.2 순차 화일

**순차 화일**은 레코드들이 하나 이상의 필드 값에 따라 오름차순으로 저장된 화일이다.

- 레코드들이 일반적으로 레코드의 탐색 키 값의 순서에 따라 저장된다.
- **탐색 키(search key)**: 순차 화일을 정렬하는데 사용되는 필드이다. 레코드들을 고유하게 식별하는 기능은 없다.
- 삽입: 레코드의 순서를 고려해야 하므로 시간이 많이 걸릴 수 있다.
- 삭제: 삭제된 레코드가 사용하던 공간이 빈 공간으로 남아 주기적으로 화일을 재조직해야 한다.
- 인덱스 없는 순차 화일은 DBMS에서 사용하지 않는다.



#### 6.4.2.1 순차 화일의 성능

```sql
SELECT CHAMPNO FROM CHAMPION WHERE CHAMPNO = 3;
```

- `CHAMPION` 화일이 `CHAMPNO`의 순서대로 저장되어 있다면 이진 탐색을 이용할 수 있어 효율적이다.

```sql
SELECT CHAMPNO FROM CHAMPION WHERE DAMAGE > = 30000;
```

- `DAMAGE`는 레코드가 저장된 순서와 무관하여 파일 전체를 탐색해야 한다.



#### 6.4.2.2 순차 화일과 연산

- 삽입, 삭제, 탐색 키가 아닌 필드로 탐색: 시간이 많이 소요
- 탐색 키로 탐색: 이진 탐색이 가능하여 효율적



예)

- 화일에 레코드가 10000000개 있다.
- 레코드의 길이는 200바이트이다.
- 블록 크기는 4096 바이트이다.
- 블로킹 인수는 4096/200 = 20이다.
  - 블로킹 인수(blocking factor)는 한 블록에 포함되는 레코드 수를 뜻한다.
- 화일에 필요한 블록 수는 10000000/20 = 500000이다.
- 특정 레코드를 찾으려면, 이진 탐색을 할 시 $log_2$50000 = 19개의 블록을 읽어야 한다.
- 하나의 블록을 읽는데 10ms가 걸리면 19 * 10ms = 190ms이 소요된다.
- 연속된 레코드들이 동일한 블록이나 인접한 블록에 있을 가능성이 높다. 순서대로 레코드들이 저장된 블록들을 물리적으로 인접한 블록들에 저장함으로써 탐구 시간을 최소화할 수 있다.



## 6.5 단일 단계 인덱스

<img src="C:\Users\jy\repos\database\image\6.14 인덱스를 통한 레코드 검색.PNG" alt="6.14 인덱스를 통한 레코드 검색" style="zoom:50%;" />

**인덱스된 순차 화일**은 **인덱스**를 통하여 임의의 레코드에 접근할 수 있다.

- 인덱스는 데이터 화일과 별개의 화일에 저장된다.
- 인덱스의 크기는 데이터 화일의 크기에 비해 훨씬 작다.
- 하나의 파일에 여러 개의 인덱스를 정의할 수 있다.



### 6.5.1 인덱스의 엔트리

<img src="C:\Users\jy\repos\database\image\6.15 EMPLOYEE 화일의 EMPNO에 정의된 인덱스.PNG" alt="6.15 EMPLOYEE 화일의 EMPNO에 정의된 인덱스" style="zoom:45%;" />

- 단일 단계 인덱스의 각 엔트리는 `<탐색 키, 레코드에 대한 포인터>`로 이루어진다.
- `레코드에 대한 포인터`는 (1) 블록 번호나 (2) 블록 번호와 블록 내의 offset으로 구성된다.
- `탐색 키`는 인덱스가 정의된 필드이다.
  - 각 <u>엔트리는 탐색 키 값의 오름차순으로 정렬</u>된다.
    - 이진 탐색을 이용하여 레코드를 탐색할 수 있다.
  - 탐색 키의 값들을 각 투플마다 반드시 고유하지는 않다.
  - 어떤 애트리뷰트도 탐색 키로 사용될 수 있다.



### 6.5.2 기본 인덱스

<img src="C:\Users\jy\repos\database\image\6.17 데이터 화일에 대한 기본 인덱스.PNG" alt="6.17 데이터 화일에 대한 기본 인덱스" style="zoom:45%;" />

**기본 인덱스(primary index)**는 탐색 키가 데이터 화일의 기본 키인 인덱스이다.

- 기본 인덱스는 기본 키의 값에 따라 정렬된 데이터 화일에 대해 정의된다.
- 기본 인덱스는 흔히 희소 인덱스로 유지할 수 있다.
- 각 릴레이션은 최대한 한 개의 기본 인덱스를 가질 수 있다.



예) 

- 화일에 레코드가 10000000개 있다.
- 레코드의 길이는 200바이트이다.
- 블록 크기는 4096 바이트이다.
- 블로킹 인수는 4096/200 = 20이다.
  - 블로킹 인수(blocking factor)는 한 블록에 포함되는 레코드 수를 뜻한다.
- 화일에 필요한 블록 수는 10000000/20 = 500000이다.
- 데이터 화일에서 각 블록마다 하나의 인덱스 엔트리가 인덱스에 들어있다.
- 한 인덱스 엔트리의 크기는 24바이트이다.
  - 블록 포인터가 4바이트, 키 필드의 길이가 20바이트
- 인덱스 블로킹 인수는 4096/24 = 170이다. 즉, 인덱스 블록당 170개의 인덱스 엔트리가 들어간다.
- 인덱스의 크기는 500000(데이터 블록 수)/170(인덱스 블록당 인덱스 엔트리 개수) = 2942 블록이다.
- 이진 탐색을 이용한다면, 하나의 레코드를 찾는데 필요한 블록 접근 횟수는 $log_2 2942$ + 1 = 13이다.
  - 1은 레코드가 들어있는 데이터 블록을 접근하는 횟수이다.
- 하나의 블록을 읽는데 10ms가 걸리면 하나의 레코드를 탐색하는데 걸리는 시간은 13 * 10ms = 130ms이다.



### 6.5.3 클러스터링 인덱스

<img src="C:\Users\jy\repos\database\image\6.19 비 클러스터링 인덱스.PNG" alt="6.19 비 클러스터링 인덱스" style="zoom:40%;" />

<img src="C:\Users\jy\repos\database\image\6.18 클러스터링 인덱스.PNG" alt="6.18 클러스터링 인덱스" style="zoom:40%;" />

**클러스터링 인덱스(clustering index)**는 탐색 키 값에 따라 정렬된 데이터 화일에 대해 정의된다.

- 각각의 상이한 키 값마다 하나의 인덱스 엔트리가 인덱스에 포함된다.
- **범위 질의**에 유용하다.
  - 범위의 시작 값에 해당하는 인덱스 엔트리를 먼저 찾는다. 범위에 속하는 인덱스 엔트리들을 따라가며 레코드들을 검색할 때 디스크에서 읽어오는 블록 수가 최소화된다.
  - 어떤 인덱스 엔트리에서 참조되는 데이터 블록을 읽어오면 그 데이터 블록에 들어 있는 대부분의 레코드들은 범위를 만족한다.



예)

- 화일에 레코드가 10000000개 있다.
- 레코드의 길이는 200바이트이다.
- 블록 크기는 4096 바이트이다.
- 블로킹 인수는 4096/200 = 20이다.
  - 블로킹 인수(blocking factor)는 한 블록에 포함되는 레코드 수를 뜻한다.
- 화일에 필요한 블록 수는 10000000/20 = 500000이다.
- 모든 레코드들에 대해 800000개의 서로 상이한 탐색 키 값들이 있다.
- 인덱스가 정의되는 필드의 길이가 20바이트이다.
- 블록당 인덱스 엔트리 수는 4096/24 = 170이다.
- 인덱스의 크기는 800000/170 = 4706 블록이다.
- 인덱스에서 어떤 키값을 만족하는 첫번째 레코드를 탐색하는데 필요한 블록 접근 횟수는 $log_24706$ +1 =14이다.
  - 1은 레코드가 들어 있는 데이터 블록을 접근하는 횟수이다.
- 하나의 블록을 읽는데 10ms가 걸리면 하나의 레코드를 탐색하는데 걸리는 시간은 14 * 10ms = 140ms이다.



### 6.5.4 보조 인덱스

<img src="C:\Users\jy\repos\database\image\6.20 보조 인덱스.PNG" alt="6.20 보조 인덱스" style="zoom:40%;" />

한 화일은 한 가지 필드들의 조합에 대해서만 정렬될 수 있다.

**보조 인덱스(secondary index)**는 탐색 키 값에 따라 정렬되지 않은 데이터 화일에 대해 정의된다.

- 보조 인덱스는 일반적으로 **밀집** 인덱스이므로 같은 수의 레코드들을 접근할 때 보조 인덱스를 통하면 기본 인덱스보다 디스크 접근 횟수가 증가할 수 있다.



예)

- 화일에 레코드가 10000000개 있다.
- 레코드의 길이는 200바이트이다.
- 블록 크기는 4096 바이트이다.
- 데이터 화일의 각 레코드마다 하나의 인덱스 엔트리가 인덱스에 들어있다.
- 한 인덱스 엔트리의 길이는 24바이트이다.
  - 블록 포인터가 4바이트, 키 필드의 길이가 20바이트
- 인덱스 블로킹 인수는 4096/24 = 170이므로 인덱스 블록당 170개의 인덱스 엔트리가 들어간다.
- 레코드의 개수가 10000000개이므로 인덱스의 크기는 10000000/170 = 58.824 블록이다.
- 이진 탐색을 이용한다면, 하나의 레코드를 찾는데 필요한 블록 접근 횟수는 $log_258824$ + 1 = 17이다.
  - 1은 레코드가 들어 있는 데이터 블록을 접근하는 횟수이다.
- 하나의 블록을 읽는데 10ms가 걸리면 하나의 레코드를 탐색하는데 걸리는 시간은 17 * 10ms = 170ms이다.



<img src="C:\Users\jy\repos\database\image\6.21 데이터 화일에 대한 밀집 인덱스.PNG" alt="6.21 데이터 화일에 대한 밀집 인덱스" style="zoom:40%;" />

### 6.5.5 희소 인덱스와 밀집 인덱스의 비교

- 희소 인덱스는 각 데이터 블록마다 한 개의 엔트리를 갖는다. 밀집 인덱스는 각 레코드마다 한 개의 엔트리를 갖는다.
- 레코드의 길이가 블록 크기보다 훨씬 작은 경우가 일반적이다. 이때 희소 인덱스의 엔트리 수가 밀집 인덱스의 엔트리 수보다 훨씬 적다.
- 희소 인덱스는 일반적으로 밀집 인덱스에 비해 인덱스 단계 수가 1 정도 적다. 그러므로 인덱스 탐색시 디스크 접근 수가 1만큼 적을 수 있다.
- 최소 인덱스는 밀집 인덱스에 비해 모든 갱신과 대부분의 질의에 대해 더 효율적이다.
  - 단 질의에서 인덱스가 정의된 애트리뷰트만 검색하는 경우, 데이터 화일에 접근할 필요 없이 인덱스만 접근하여 질의를 수행할 수 있으므로 밀집 인덱스가 희소 인덱스보다 유리하다.
- 한 화일은 한 개의 희소 인덱스와 다수의 밀집 인덱스를 가질 수 있다.



### 6.5.6  클러스터링 인덱스와 보조 인덱스의 비교

- 클러스터링 인덱스는 희소 인덱스일 경우가 많으며 범위 질의 등에 좋다.
- 보조 인덱스는 밀집 인덱스이므로 일부 질의에 대해서는 화일을 접근할 필요 없이 처리할 수 있다.



## 6.6  다단계 인덱스

<img src="C:\Users\jy\repos\database\image\6.22 다단계 인덱스.PNG" alt="6.22 다단계 인덱스" style="zoom:40%;" />

인덱스 자체가 큰 경우 인덱스를 탐색하는 시간이 오래 걸린다. 따라서 인덱스 엔트리를 탐색하는 시간을 줄이기 위해 단일 단계 인덱스를 디스크 상의 하나의 순서 화일로 간주하고, 단일 단계 인덱스에 대하여 인덱스를 정의한다. 이것을 **다단계 인덱스**라고 한다.

- 다단계 인덱스는 가장 상위 단계의 모든 인덱스 엔트리들이 하나의 블록에 들어갈 수 있을 때까지 위 과정을 반복한다.
- 가장 상위 단계의 인덱스를 **마스터 인덱스(master index)**라고 한다.
- 마스터 인덱스는 한 블록으로 이루어지므로 주기억 장치에 상주할 수 있다.
- 대부분의 다단계 인덱스는 B+- 트리(균형 이진 탐색 트리를 일반화한 것)를 사용한다.



예) 기본 키에 대한 다단계 인덱스

- 1단계 인덱스의 블록 수는 2942개이다.
- 1단계 인덱스의 블록 수는 2942/170 = 18개이다.
- 3단계 인덱스의 블록 수는 18/170 = 1개로 주기억 장치에 상주할 수 있다.

원하는 레코드를 탐색하려면, 3단계 인덱스는 주기억 장치에 상주하므로 디스크 접근이 필요하지 않다. 2단계 인덱스를 구성하는 블록 중 하나, 1단계 인덱스를 구성하는 블록 중 하나, 데이터 화일의 블록 중 하나 등 총 세 번의 디스크 접근이 필요하다.

- 하나의 블록을 읽는데 10ms가 걸리면 하나의 레코드를 탐색하는데 걸리는 시간은 3 * 10ms = 30ms이다.



### 6.6.1 SQL의 인덱스 정의문

- SQL의 `CREATE TABLE`문에서 기본 키로 지정한 애트리뷰트에 대해서 DBMS가 자동적으로 기본 인덱스를 생성한다.
- `UNIQUE`로 명시한 애트리뷰트에 대해서 DBMS가 자동적으로 보조 인덱스를 생성한다.
-  SQL2는 인덱스 정의 및 제거에 관한 표준 SQL문을 제공하지 않는다.
- 다른 애트리뷰트에 추가로 인덱스를 정의하려면 DBMS마다 다소 구문이 다른 `CREATE INDEX`문을 사용한다.



### 6.6.2 다수의 애트리뷰트를 사용한 인덱스 정의

```sql
CREATE INDEX CmpIndex ON CHAMPION (CHAMPNO, DAMAGE);
```

- 한 릴레이션에 속하는 두 개 이상의 애트리뷰트들의 조합에 대해 인덱스를 정의할 수 있다.

```sql
SELECT * FROM CHAMPION WHERE CHAMPNO = 3 AND DAMAGE = 30000;
```

```sql
SELECT * FROM CHAMPION WHERE CHAMPNO >= 3 AND DAMAGE >= 30000;
```

```sql
SELECT * FROM CHAMPION WHERE CHAMPNO = 3;
```

- 이 인덱스는 위 질의에 활용될 수 있다.

```sql
SELECT * FROM CHAMPION WHERE DAMAGE >= 30000;
```

- 그러나 이 질의에서는 활용할 수 없다. `CHAMPNO`로 레코드가 정렬되어 있고, 그 다음에 `DAMAGE` 순으로 정의되어 있기 때문이다. 결국 모든 레코드를 탐색해야 한다.



### 6.6.3 인덱스의 장점과 단점

- 단점: (1) 인덱스를 저장하기 위해 공간이 추가적으로 필요하다. (2) 삽입, 삭제, 수정 연산을 하면 인덱스에 반영해야 하므로 연산의 속도가 저하된다.
- 장점: (1) 인덱스는 검색 속도를 향상시킨다. (2) 소수의 레코드를 수정하거나 삭제하는 연산의 속도는 향상된다. (3) 릴레이션이 매우 크고 질의에서 릴레이션의 투프들 중에 일부(2%~4%)를 검색하고 WHERE절이 잘 표현되었다면 특히 효율적이다.



## 6.7 인덱스 선정 지침과 데이터베이스 튜닝

- 가장 중요한 질의들과 이들의 수행 빈도, 가장 중요한 갱신들과 이들의 수행 빈도 등 질의 와 갱신들에 대한 바람직한 성능을 고려하여 인덱스를 선정한다.
- 워크로드(자주 사용하는 질의 모음) 내의 각 질의에 대해 이 질의가 (1) 어떤 릴레이션을 접근하는가 (2) 어떤 애트리뷰트들을 검색하는가 (3) `WHERE`절의 선택/조인 조건에 어떤 애트리뷰트들이 포함되는가 (4) 이 조건들의 선별력은 얼마인가 등을 고려한다.
- 워크로드 내의 각 갱신에 대해 이 갱신이 (1) 어떤 릴레이션을 접근하는가 (2) `WHERE`절의 선택/조인 조건에 어떤 애트리뷰트들이 포함되는가 (3) 이 조건들의 선별력(선택되는 레코드가 적다면 선별력이 좋음)은 얼마인가 (4) 갱신 유형(`INSERT`/`DELETE`/`UPDATE`), 갱신의 영향을 받는 애트리뷰트들을 고려한다.
- (1) 어떤 인덱스에 인덱스를 생성해야 하는가 (2) 어떤 애트리뷰트를 탐색 키로 선정해야 하는가 (3) 몇 개의 인덱스를 생성해야 하는가 (4) 각 인덱스에 대해 클러스터링/밀집/희소 인덱스 중 어느 유형을 선택할 것인지 고려한다.
- 인덱스를 선정하는 한 가지 방법은 가장 중요한 질의들을 차례로 고려하고, 현재의 인덱스가 최적의 계획에 적합한지 고려하고 인덱스를 추가하면 더 좋은 계획이 가능한지 알아본다.
- 물리적 데이터베이스 설계는 끊임없이 이루어지는 작업이다.



### 6.8.1 인덱스를 결정하는데 도움이되는 지침

- 지침 1: 기본 키는 클러스터링 인덱스를 정의할 훌륭한 후보이다.
- 지침 2: 외래 키도 인덱스를 정의할 중요한 후보이다.
- 지침 3: 한 애트리뷰트에 들어 있는 상이한 값들의 개수가 거의 전체 레코드 수와 비슷하고, 그 애트리뷰트가 동등 조건에 사용된다면 비 클러스터링 인덱스를 생성하는 것이 좋다.
- 지침 4: 투플이 많이 들어 있는 릴레이션에서 대부분의 질의가 검색하는 투플이 2%~4% 미만인 경우에는 인덱스를 생성한다.
- 지침 5: 자주 갱신되는 애트리뷰트에는 인덱스를 정의하지 않는 것이 좋다.
- 지침 6: 갱신이 빈번하게 이루어지는 릴레이션에는 인덱스를 많이 만드는 것을 피한다.
- 지침 7: 후보 키는 기본 키가 갖는 모든 특성을 마찬가지로 갖기 때문에 인덱스를 생성한 후보이다.
- 지침 8: 인덱스는 화일의 레코드들을 충분히 분할할 수 있어야 한다.
- 지침 9: 정수형 애트리뷰트에 인덱스를 생성한다.
- 지침 10: 긴 `VARCHAR` 애트리뷰트에는 인덱스를 만들지 않는다.
- 지침 11: 작은 화일에는 인덱스를 만들 필요가 없다.
- 지침 12: 대량의 데이터를 삽입할 때는 모든 인덱스를 제거하고 데이터 삽입이 끝난 후에 인덱스를 다시 생성하는 것이 좋다.
- 지침 13: `ORDER BY`, `GROUP BY`절에 자주 사용되는 애트리뷰트는 인덱스를 정의할 후보이다.



### 6.8.2 언제 인덱스가 사용되지 않는가?

- 시스템에 카탈로그가 오래 전의 데이터베이스 상태를 나타낸다.
- DBMS의 질의 최적화 모듈이 릴레이션의 크기가 작아서 인덱스가 도움이 되지 않는다고 판단한다.

```sql
SELECT * FROM CHAMPION WHERE DAMAGE * 12 > 400000;
```

- 인덱스가 정의된 애트리뷰트에 산술 연산자가 사용된다.

```sql
SELECT * FROM CHAMPION WHERE SUBSTR(CHAMPNAME, 1, 1) = '구';
```

- DBMS가 제공하는 내장 함수가 집단 함수 대신에 사용된다.

```sql
SELECT * FROM CHAMPION WHERE CHAMPNAME IS NULL;
```



### 6.8.3 질의 튜닝을 위한 추가 지침

- `DISTINCT`절의 사용을 최소화한다.
- `GROUP BY`절과 `HAVING`절의 사용을 최소화한다.
- 임시 릴레이션의 사용을 피한다.
- `SELECT *` 대신 `SELECT`절에 필요한 애트리뷰트 이름을 구체적으로 명시한다.