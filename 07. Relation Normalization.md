# 07. Relation Normalization

- 부주의한 데이터베이스 설계는 데이터 중복을 야기하고 여러 가지 **갱신 이상(update anomaly)**을 유발한다.
- **정규화(normalization)**: 주어진 릴레이션 스키마를 함수적 종속성과 기본 키를 기반으로 분석하여, 원래의 릴레이션을 분해함으로써 중복과 세 가지의 갱신 이상을 최소화하는 것



## 7.1 정규화 개요

- 좋은 관계 데이터베이스 스키마를 설계하는 목적은 다음과 같다.

  - 정보의 중복과 갱신 이상이 생기지 않도록 한다.

  - 정보의 손실을 막는다.

  - 실세계를 훌륭하게 나타내어, 애트리뷰트들 간의 관계가 잘 표현되는 것을 보장한다.

  - 어떤 무결성 제약조건의 시행을 간단하게 하고 효율성 측면을 고려한다.

먼저 갱신 이상이 나타나지 않도록 한 후 효율성을 고려한다.



- 나쁘게 설계된 릴레이션 또는 정규화 되지 않은 릴레이션은 저장 공간을 낭비하고 세 가지 갱신 이상을 유발한다.



### 7.1.1 갱신 이상

갱신 이상은 다음 세 가지 문제를 뜻한다.

- **수정 이상(modification anomaly)**: 반복된 데이터 중 일부만 수정하면 데이터의 불일치가 발생한다.
- **삽입 이상(insertion anomaly)**: 불필요한 정보를 함께 저장하지 않고는 어떤 정보를 저장하는 것이 불가능하다.
- **삭제 이상(deletion anomaly)**: 유용한 정보를 함께 삭제하지 않고는 어떤 정보를 삭제하는 것이 불가능하다.



### 7.1.2 릴레이션 분해

정규화가 진행되면 릴레이션이 분해된다.

- **릴레이션 분해**: 하나의 릴레이션을 두 개 이상의 릴레이션으로 나누는 것이다.
- 릴레이션의 분해는 필요한 경우 분해된 릴레이션들로부터 원래의 릴레이션을 다시 구할 수 있음을 보장해야 한다는 원칙을 기반으로 한다.
- 분해를 잘못하면 손실이 발생할 수 있다: 두 릴레이션으로부터 얻을 수 있는 정보가 원래의 릴레이션이 나타내던 정보보다 적거나 많을 수 있다.
- 릴레이션의 분해는 릴레이션에 존재하는 함수적 종속성에 관한 지식을 기반으로 한다.



### 7.1.3 정규화의 종류

정규화에는 다음과 같은 종류가 있다.

- **제1정규형(first normal form)**
- **제2정규형(second normal form)**
- **제3정규형(third normal form)**
- **BCNF(Boyce-Codd normal form)**
- **제4정규형(fourth normal form)**
- **제5정규형(fifth normal form)**



### 7.1.4 관계 데이터베이스 설계의 비공식적인 지침

- (1) 이해하기 쉽고 명확한 스키마를 만든다.
- (2) 널값을 피한다.
- (3) 가짜 투플이 생기지 않도록 한다.
- (4) 스키마를 정제한다.



## 7.2 함수적 종속성

**함수적 종속성(FD: Functional Dependency)**는 정규화 이론의 핵심이다.

- 함수적 종속성은 릴레이션의 애트리뷰트들의 의미로부터 결정된다.
- 함수적 종속성은 릴레이션 스키마에 대한 주장이지 릴레이션의 특정 인스턴스에 대한 주장이 아니다.
- 함수적 종속성은 릴레이션의 가능한 모든 인스턴스들이 만족해야 한다.

함수적 종속성은 제2정규형부터 BCNF까지 적용된다.



### 7.2.1 결정자

<img width="1027" alt="함수적 종속성" src="https://user-images.githubusercontent.com/57662010/144853423-5f987516-01b7-4935-8449-587a95ef61a0.PNG" style="zoom:80%;" >

- 어떤 애트리뷰트의 값은 다른 애트리뷰트의 값을 고유하게 결정할 수 있다.
- **결정자(determinant)**: 주어진 릴레이션에서 다른 애트리뷰트(또는 애트리뷰드들의 집합)를 고유하게 결정하는 하나 이상의 애트리뷰트를 의미한다.
- 릴레이션 R에서 애트리뷰트 A가 B의 결정자이면, 임의의 두 투플에서 A 애트리뷰트의 값이 같을 때 B 애트리뷰트의 값도 같아야 한다.
- 결정자는 $A\rightarrow B$와 같이 표기하며, "A가 B를 결정한다" 또는 "A는 B의 결정자이다"라고 말한다.



예) `챔피언번호`가 4329이면, `챔피언이름`은 무조건 비에고이다.

예) `챔피언번호`기 3111이면 `챔피언이름`은 무조건 그레이브즈이다.



### 7.2.2 함수적 종속성

<img width="919" alt="함수적 종속성 다이어그램" src="https://user-images.githubusercontent.com/57662010/144853631-c3df8fe0-baaa-4fa8-851a-f3dfa8abdb7b.PNG" style="zoom:67%;" >

- 만일 애트리뷰트 A가 애트리뷰트 B의 결정자이면 B가 A에 함수적으로 종속한다고 말한다.
- 즉, 주어진 릴레이션 R에서 애트리뷰트 B가 애트리뷰트 A에 함수적으로 종속하는 필요 충분 조건은 각 A 값에 대해 반드시 한 개의 B 값이 대응된다.



예) `챔피언번호`는 `챔피언이름`, `출신지`의 결정자이므로  `챔피언이름`, `출신지`는 `챔피언번호`에 함수적으로 종속한다.

하지만 `직군`은 (`챔피언번호`, `라인번호`)에 함수적으로 종속하지, `챔피언번호`에 함수적으로 종속하지 않는다.

가령 카르마는 대개 탑에 가면 탱커지만 바텀에 가면 서포터다.

카르마의 직군은 카르마가 서는 라인에 따라 달라지므로 `직군`은 `(챔피언번호, 라인번호)`에 완전하게 함수적으로 종속한다.



### 7.2.3 완전 함수적 종속성

<img src="image\7.6 완전 부분 함수적 종속성 1.PNG" alt="7.6 완전 부분 함수적 종속성 1" style="zoom:40%;" />

<img src="image\7.6 완전 부분 함수적 종속성 2.PNG" alt="7.6 완전 부분 함수적 종속성 2" style="zoom:30%;" />

- 주어진 릴레이션 R에서 애트리뷰트 B가 애트리뷰트 A에 함수적으로 종속하면서 애트리뷰트 A의 어떤 진부분 집합에도 함수적으로 종속하지 않으면 애트리뷰트 B는 애트리뷰트 A에 완전하게 함수적으로 종속한다.
- 애트리뷰트 A는 복합 애트리뷰트이다. 즉, A가 단일한 애트리뷰트라면 완전 함수적 종속성인지 부분 함수적 종속성인지 따지지 않는다.
- $A\rightarrow B$로 표현한다.
- 완전하게 함수적으로 종속하지 않으면 부분 함수적 종속성을 갖는다고 말한다.



### 7.2.4 이행적 함수적 종속성

<img src="image\7.7 이행적 함수적 종속성.PNG" alt="7.7 이행적 함수적 종속성" style="zoom:35%;" />

- 한 릴레이션의 애트리뷰트 A, B, C에 대하여 애트리뷰트 C가 이행적으로 A에 종속한다(A $\rightarrow$ C)는 것의 필요 충분 조건은 $A \rightarrow B \and B \rightarrow C$가 성립하는 것이다.
- A가 릴레이션의 기본 키라면 키의 정의에 따라  $A \rightarrow B$와 $A \rightarrow C$가 성립한다. 만일 C가 A 외에 B에도 함수적으로 종속한다면 C는 A에 직접 함수적으로 종속하면서 B를 거쳐서 A에 이행적으로 종속한다.
- 이행적 종속성이 존재하는 릴레이션에는 키가 아닌 애트리뷰트가 적어도 두 개 이상 있어야 한다.



## 7.3 릴레이션 분해

**릴레이션 분해(decomposition)**는 하나의 릴레이션을 두 개 이상의 릴레이션으로 나누는 것이다.

- 릴레이션을 분해하면 중복이 감소되고 갱신 이상이 줄어드는 장점이 있다.
- 그러나 바람직한 문제들을 포함항 몇 가지 잠재적 문제를 야기할 수 있다.
  - 릴레이션이 분해되기 전에는 조인이 필요 없는 질의가 분해 후에는 조인을 필요로 하는 질의로 바뀔 수 있다.
  - 분해된 릴레이션들을 사용하여 원래의 릴레이션을 재구성하지 못할 수 있다.



### 7.3.1 무손실 분해

**무손실 분해(lossless decomposition)**: 두 릴레이션을 조인할 때 원래의 릴레이션에 들어 있는 정보를 완전하게 얻을 수 있는 경우의 릴레이션 분해이다.

- 손실이란 정보의 손실을 뜻한다.
- 정보의 손실: 원래의 릴레이션을 분해한 후 생성된 릴레이션들을 조인한 결과에 들어 있는 정보가 원래의 릴레이션에 들어 있는 정보보다 적거나 많은 경우를 의미한다.

<img src="image\7.12 가짜 투플.PNG" alt="7.12 가짜 투플" style="zoom:50%;" />





## 7.4 제1정규형, 제2정규형, 제3정규형, BCNF

### 7.4.1 제1정규형

- 한 릴레이션 R이 제1정규형을 만족할 필요 충분 조건은 릴레이션 R의 모든 애트리뷰트가 원자값만을 갖는다는 것이다.
- 즉, 릴레이션의 모든 애트리뷰트에 **반복 그룹(repeating group)**이 나타나지 않으면 제1정규형을 만족한다.

ER 스키마의 다치 애트리뷰트를 관계 데이터베이스 모델로 사상할 때와 비슷하다.



<img src="image\7.13 반복 그룹.PNG" alt="7.13 반복 그룹" style="zoom:35%;" />

#### 7.4.1.1 제1정규형을 만족하지 않는 릴레이션을 제1정규형으로 변환하기

두 가지 방법이 있다.

- (1) 반복 그룹 애트리뷰트에 나타나는 집합에 속한 각 값마다 하나의 투플로 표현

<img src="image\7.14 원자값만 있는 릴레이션.PNG" alt="7.14 원자값만 있는 릴레이션" style="zoom:40%;" />

- (2) 모든 반복 그룹 애트리뷰트들을 분리해서 새로운 릴레이션에 넣는다. 원래 릴레이션의 기본 키를 새로운 릴레이션에 애트리뷰트로 추가한다.

<img src="image\7.15 두 릴레이션으로 분해.PNG" alt="7.15 두 릴레이션으로 분해" style="zoom:40%;" />

#### 7.4.1.2 제1정규형에 존재하는 갱신 이상

<img src="image\7.16 제1정규형을 만족하는 릴레이션.PNG" alt="7.16 제1정규형을 만족하는 릴레이션" style="zoom:40%;" />

학생 릴레이션에서 모든 애트리뷰트가 원자값을 가진다면 제1정규형을 만족한다. 릴레이션의 기본 키는 `(학번, 과목번호)`이다.

그러나 다음과 같은 갱신 이상이 발생할 수 있다.

- 수정 이상: 학과 전화번호가 변경되면 해당 학과 학생의 투플에서 전화번호를 모두 수정해야 함. 그렇지 않으면 데이터베이스의 일관성이 유지되지 않는다.
- 삽입 이상: 학과에 학생이 없다면 투플을 삽입할 수 없음. 학번이 기본 키의 구성요소이기 때문에 엔티티 무결성 제약조건에 따라 널값을 입력할 수 없기 때문.
- 삭제 이상: 학생을 전부 삭제하면 학과 정보도 사라짐.



기본 키에 대한 부분 함수적 종속성이 학생 릴레이션에 존재하기 때문에 갱신 이상이 생긴다.

<img src="image\7.17 갱신 이상.PNG" alt="7.17 갱신 이상" style="zoom:45%;" />

### 7.4.2 제2정규형

- 한 릴레이션 R이 제2정규형을 만족할 필요 충분 조건은 릴레이션 R이 제1정규형을 만족하면서, 어떤 후보 키에도 속하지 않는 모든 애트리뷰트들이 R의 기본 키에 완전하게 함수적으로 종속하는 것이다.
- 기본 키가 두 개 이상의 애트리뷰트로 구성되었을 경우에만 제1정규형이 제2정규형을 만족하는가 고려할 필요가 있다.



#### 7.4.2.1 제2정규형에 존재하는 갱신 이상

<img src="image\7.18 제2정규형을 만족하는 릴레이션.PNG" alt="7.18 제2정규형을 만족하는 릴레이션" style="zoom:35%;" />

`학생1` 릴레이션의 기본 키는 한 애트리뷰트인 `학번`이므로 제2정규형을 만족한다.

그러나 다음과 같은 갱신 이상이 발생할 수 있다.

- 수정 이상 : 학과 전화번호가 변경되면 해당 학과 학생의 투플에서 전화번호를 모두 수정해야 함. 그렇지 않으면 데이터베이스의 일관성이 유지되지 않는다.
- 삽입 이상:  학과에 학생이 없다면 투플을 삽입할 수 없음. 학번이 기본 키의 구성요소이기 때문에 엔티티 무결성 제약조건에 따라 널값을 입력할 수 없기 때문.
- 삭제 이상: 학생을 전부 삭제하면 학과의 전화번호도 사라진다.



`학생1` 릴레이션에 이행적 종속성이 존재하기 때문에 갱신 이상에 생긴다.

<img src="image\7.19 제2정규형을 만족하는 릴레이션.PNG" alt="7.19 제2정규형을 만족하는 릴레이션" style="zoom:50%;" />



### 7.4.3 제3정규형

- 한 릴레이션 R이 제3정규형을 만족할 필요 충분 조건은 릴레이션 R이 제2정규형을 만족하면서 키가 아닌 모든 애트리뷰트가 릴레이션 R의 기본 키에 이행적으로 종속하지 않는 것이다.





#### 7.4.3.1 제3정규형에 존재하는 갱신 이상

<img src="image\7.21 수강 릴레이션에 존재하는 함수적 종속성.PNG" alt="7.21 수강 릴레이션에 존재하는 함수적 종속성" style="zoom:40%;" />

- 릴레이션의 기본 키는 `(학번, 과목)`이다.

- 키가 아닌 강사 애트리뷰트가 기본 키에 완전하게 함수적으로 종속하므로 제2정규형을 만족하고, 키가 아닌 강사 애트리뷰트가 기본 키에 직접 종속하므로 제3정규형도 만족한다.
- 이 릴레이션에는 아래와 같은 함수적 종속성들이 존재한다.

`(학번, 과목)` $\rightarrow$ 강사

강사 $\rightarrow$ 과목



다음과 같은 갱신 이상이 발생할 수 있다.

- 수정 이상 : 강사가 변경되면 해당 학과 학생의 투플에서 강사를 모두 수정해야 함. 그렇지 않으면 데이터베이스의 일관성이 유지되지 않는다.
- 삽입 이상:  강의에 수강하는 학생이 없다면 투플을 삽입할 수 없음. 학번이 기본 키의 구성요소이기 때문에 엔티티 무결성 제약조건에 따라 널값을 입력할 수 없기 때문.
- 삭제 이상: 수강 학생을 전부 삭제하면 강사 정보도 사라진다.



키가 아닌 애트리뷰트가 다른 애트리뷰트를 결정하기 때문에 갱신 이상이 발생한다. `수강` 릴레이션의 후보 키는 `(학번, 과목)`과 `(학번, 강사)`이다.



### 7.4.4 BCNF

- 한 릴레이션 R이 BCNF를 만족할 필요 충분 조건은 릴레이션 R이 제3정규형을 만족하고 모든 결정자가 후보 키여야 한다.
- `수강` 릴레이션의 강사 애트리뷰트는 후보 키가 아니지만 과목 애트리뷰트를 결정하므로 BCNF가 아니다.
- 제3정규형을 만족하는 대부분의 릴레이션들로 BCNF도 만족한다.
- 하나의 후보 키만을 가진 릴레이션은 제3정규형을 만족하면 동시에 BCNF도 만족한다.
- 제3정규형을 만족하는 릴레이션을 BCNF로 정규화하려면 키가 아니면서 결정자 역할을 하는 애트리뷰트와 그 결정자에 함수적으로 종속하는 애트리뷰트를 하나의 테이블에 넣는다. 이 릴레이션에서 결정자는 기본키가 된다. 그리고 기존 릴레이션에 결정자를 남겨 기본 키의 구성 요소가 되도록 한다. 또한 이 결정자는 새로운 릴레이션에 대한 외래 키 역할을 한다.

<img src="image\7.22 제3정규형을 만족하지만 BCNF는 만족하지 않는 릴레이션.PNG" alt="7.22 제3정규형을 만족하지만 BCNF는 만족하지 않는 릴레이션" style="zoom: 40%;" />

<img src="image\7.23 제3정규형을 BCNF로 분해.PNG" alt="7.23 제3정규형을 BCNF로 분해" style="zoom:40%;" />

<img src="image\7.24 제3정규형을 BCNF로 정규화.PNG" alt="7.24 제3정규형을 BCNF로 정규화" style="zoom:45%;" />



### 7.4.5 여러 정규형의 요약

<img src="image\7.25 각 정규형의 특징과 정규화 과정.PNG" alt="7.25 각 정규형의 특징과 정규화 과정" style="zoom:50%;" />



## 7.5 역정규화

- 정규화 단계가 진행될수록 중복과 갱신 이상이 감소된다.
- 정규화가 진전될수록 무결성 제약조건을 시행하기 위해 필요한 코드의 양도 감소된다.
- 정규화가 데이터베이스 설계의 중요한 요소이나 성능상의 관점에서만 보면 높은 정규형을 만족하는 릴레이션 스키마가 최적인 것은 아니다.
- 한 정규형에서 다음 정규형으로 진행될 때마다 하나의 릴레이션이 최소한 두 개의 릴레이션으로 분해된다.
- 분해되기 전의 릴레이션을 대상으로 질의를 할 때는 조인이 필요 없지만 분해된 릴레이션을 대상으로 질의를 할 때는 같은 정보를 얻기 위해 보다 많은 릴레이션들을 접근해야 하므로 조인의 필요성이 증가한다.



<img src="image\7. 조인의 필요성.PNG" alt="7. 조인의 필요성" style="zoom:45%;" />



- 때로는 **역정규화(denormalization)**을 통해 데이터 중복 및 갱신 이상을 대가로 성능상의 요구를 만족시키기도 한다.
- 많은 데이터베이스 응용에서 검색 질의의 비율이 갱신 질의의 비율보다 훨씬 높다. 역정규화는 주어진 응용에서 빈번하게 수행되는 검색 질의들의 수행 속도를 높이기 위해 이미 분해된 두 개 이상의 릴레이션들을 합쳐 하나의 릴레이션으로 만드는 작업이다.
- 즉 역정규화는 보다 낮은 정규형으로 돌아가는 것이다.

<img src="image\7.26 역정규화된 릴레이션.PNG" alt="7.26 역정규화된 릴레이션" style="zoom:40%;" />

