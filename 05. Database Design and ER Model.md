# 05. Database Design and ER Model

**데이터베이스 설계(database design)**는 미리 정의된 응용들의 모임을 위해 조직체의 사용자들의 정보 요구를 수용하여 <u>하나 이상의 데이터베이스의 논리적인 구조와 물리적인 구조를 설계하는 것</u>이다.

- 데이터베이스 설계는 <u>(1) 개념적 데이터베이스 설계와 (2) 물리적 데이터베이스 설계로 구분</u>한다.
- **개념적 데이터베이스**는 개념적인 구조를 다룬다.
  - 실제로 데이터베이스를 어떻게 구현할 것인가와 독립적으로 정보 사용의 모델을 개발하는 과정이다.
  - 조직체(실세계)의 엔티티, 관계, 프로세스, 무결성 제약조건 등을 나타내는 추상화 모델을 구축한다.
  - **엔티티**: 서로 구분이 되면서, 조직체에서 데이터베이스에 나타내려는 객체(사람, 장소, 사물 등)를 의미한다.
  - **관계**: 두 개 이상의 엔티티들 간의 연관을 의미한다.
  - **프로세스**: 관련된 활동을 의미한다.
  - **무결성 제약조건**: 데이터의 정확성과 비지니스 규칙을 의미한다.
- **물리적 데이터베이스 설계**는 물리적인 저장 장치와 접근 방식을 다룬다.



개념적 수준의 모델은 특정 데이터 모델과 독립적으로 응용 세계를 모델링할 수 있도록 한다.

- 데이터베이스 구조나 스키마를 하향식으로 개발할 수 있기 위한 틀(framework)를 제공한다.
- *엔티티-관계(ER: Entity-Relationship) 모델*은 가장 많이 쓰이는 개념적 데이터 모델이다.
- 개념적 데이터 모델이 사상될 수 있는 *구현 데이터 모델(implementation data model)*들이 존재한다.
- 구현 단계에서는 다음 세 가지 모델이 사용된다.
  - 관계 데이터 모델
  - 계층 데이터 모델
  - 네트워크 데이터 모델



## 5.1 데이터베이스 설계의 개요

데이터베이스 설계는 모든 주요 응용과 사용자들이 요구하는 데이터, 데이터 간의 관계를 표현하는 것이다. 즉 요구에 맞게 데이터베이스를 생성하는 과정이다.

<img src=".\image\5.1 데이터베이스 개발의 라이프 사이클.PNG" alt="5.1 데이터베이스 개발의 라이프 사이클" style="zoom:55%;" />

직사각형: 설계의 주요 단계

타원형: 각 단계의 결과물

<img src=".\image\5.1 데이터베이스 설계의 주요 단계.PNG" alt="5.1 데이터베이스 설계의 주요 단계" style="zoom:60%;" />



### 5.1.1 요구사항 수집과 분석

- 작은 세계: 데이터베이스에 표현하려는 실세계의 한 부분(도메인)이다.
- **요구사항 수집**: 기존의 문서를 조사하고, 인터뷰나 설문 조사를 시행한다.
  - 설문 조사는 (1) 자유롭게 의견을 적어내는 방식과 (2) 주어진 질문에 대해서 답을 하는 방식으로 구분한다.
- **요구사항 분석**: 요구사항에 관한 지식을 기반으로 다음을 파악한다.
  - 관련 있는 엔티티들과 이들의 애트리뷰트들이 무엇인가
  - 엔티티들 간의 관계가 무엇인가
  - 데이터 처리에 관한 요구사항에 대해 전형적인 연산은 무엇인가
  - 연산들의 의미, 접근하는 데이터의 양



### 5.1.2 개념적 설계

**개념적 설계 단계**는 모든 물리적인 사항과 독립적이며, 한 조직체에서 사용되는 정보의 모델을 구축하는 과정이다.

- 높은 추상화 수준의 데이터 모델을 기반으로 정형적인 언어로 데이터 구조를 명시한다.
  - 대표적인 개념적 데이터 모델: ER 모델

- 개념적 설계 단계에서는 사용자들의 요구사항 명세로부터 개념적 스키마를 만든다.
  - 엔티티 타입, 관계 타입, 애트리뷰트들을 식별한다.
  - 애트리뷰트들의 도메인을 결정한다.
  - 후보 키와 기본 키 애트리뷰트르 결정한다.
- 개념적 스키마(ER 스키마)는 *ER 다이어그램*으로 표현한다.



### 5.1.3 DBMS 선정

DBMS를 선정할 때에는 다음 세 요인들을 고려한다.

- 기술적인 요인: DBMS가 제공하는 데이터 모델, 저장 구조, 인터페이스, 질의어, 도구, 제공되는 서비스 등
- 정치적인 요인: 고수준의 전략적인 결정 등
- 경제적인 요인: DBMS/하드웨어 구입 비용, 유지 보수 비용, 마이그레이션 비용, 인건비, 교육비 등



### 5.1.4 논리적 설계

**논리적 설계 단계**는 선택한 DBMS의 데이터 모델을 사용하여 논리적 스키마(외부 스키마 포함)를 생성한다. 그 과정은 아래와 같다.

- 개념적 스키마에 알고리즘을 적용하여 논리적 스키마를 생성한다.
- 관계 데이터 모델을 사용하여 개념적 스키마를 나타내는 경우, ER 모델로 표현된 개념적 스키마를 관계 데이터베이스 스키마로 사상한다.



### 5.1.5 정규화

- 관계 데이터베이스 스키마를 더 좋은 관계 데이터베이스 스키마로 변환하기 위하여 정규화 과정을 적용한다.



### 5.1.6 물리적 설계

- **물리적 설계 단계**에서는 처리 요구사항들을 만족하기 위해 저장 구조와 접근 경로 등을 결정한다.
- 성능을 판단하는 기준을 다음과 같이 구분할 수 있다.
  - 응답 시간: 평균적으로 혹은 피크 시간 때 질의와 갱신이 얼마나 오래 걸리는가
  - 트랜잭션 처리율: 평균적으로 혹은 피크 시간 때 1초당 얼마나 많은 트랜잭션이 처리될 수 있는가
  - 전체 데이터베이스에 대한 보고서를 생성하는데 얼마나 오래 걸리는가



### 5.1.7 트랜잭션 설계

- 요구사항 수집과 분석 단계 이후 트랜잭션 설계를 진행할 수 있다.
- **트랜잭션**은 완성될 데이터베이스에서 동작할 응용 프로그램이다.
- 데이터베이스 스키마는 트랜잭션에서 요구하는 모든 정보를 포함해야 한다.
- 트랜잭션은 검색, 갱신, 혼합 등 세 가지 유형으로 구분하여 입력과 출력, 동작 등을 식별한다.



## 5.2 ER 모델

- ER 모델은 P.P.Chen이 데이터베이스 설계를 용이하게 하기 위해 제안하였음
- 현재 EER(Enhanced Entity Relationship) 모델이 데이터베이스 설계 과정에 널리 사용되고 있음
- ER 모델은 다음과 같은 특징을 가진다.
  - 실세계를 엔티티, 애트리뷰트, 엔티티들 간의 관계로 표현한다.
  - 기본적인 구문으로는 엔티티, 관계, 애트리뷰트가 있다.
  - 기타 구문으로는 카디날리티 비율, 참여 제약조건 등이 있다.
  - 쉽게 관계 데이터 모델로 사상된다.
- 많은 CASE 도구(예: ERWin)가 ER 모델을 기반으로 한다.
  - ER 설계를 자동적으로 SQL Server, 오라클, 사이베이스 등의 데이터 정의어 혹은 XML로 변환한다.
- ER 모델은 다소 구형 그래픽 표기법이다.



### 5.2.1 엔티티

- 하나의 엔티티는 사람, 장소, 사물 등과 같이 독립적으로 존재하며, 고유하게 식별할 수 있는 실세계의 객체이다. 실체가 없이 생각이나 개념처럼 추상적인 것도 있다.



### 5.2.2 엔티티 타입

<img width="562" alt="entity" src="https://user-images.githubusercontent.com/57662010/142882340-1395ffb6-acad-4c51-af20-fec00e8f413a.PNG" style="zoom:80%;" >

- **엔티티**들은 엔티티 타입 또는 엔티티 집합들로 분류된다.
- **엔티티 타입**: 동일한 애트리뷰트들을 가진 엔티티의 틀, 관계 모델의 릴레이션의 내포에 해당
- **엔티티 집합**: 동일한 애트리뷰트들을 가진 엔티티들의 모임, 관계 모델의 릴레이션의 외연에 해당
- 하나의 엔티티는 한 개 이상의 엔티티 집합에 속할 수 있다.
- 엔티티 집합과 엔티티 타입을 엄격하게 구분하지 않아도 된다.
- 엔티티에는 두 가지 종류가 있다.
  - **강한 엔티티 타입(정규 엔티티 타입)**: 독자적으로 존재하며, 엔티티 타입 내에서 자신의 키 애트리뷰트를 사용하여 고유하게 엔티티들을 식별할 수 있는 엔티티 타입이다.
  - **약한 엔티티 타입**: 키를 형성하기에 충분한 애트리뷰트를 갖지 못한 엔티티 타입이다.
    - **소유 엔티티 타입**의 키 애트리뷰트를 결합하여 고유하게 약한 엔티티 타입의 엔티티들을 식별할 수 있다.
- ER 다이어그램에서 엔티티 타입은 직사각형으로 나타낸다.



### 5.2.3 애트리뷰트

- 하나의 **애트리뷰트**는 연관된 애트리뷰트들의 집합이다.
- 하나의 **애트리뷰트의 도메인**은 그 애트리뷰트가 가질 수 있는 모든 가능한 값들의 집합이다.
- 여러 애트리뷰트가 동일한 도메인을 공유할 수 있다.
- 키 애트리뷰트는 하나의 애트리뷰트 또는 애트리뷰트들의 모임으로서 한 엔티티 타입 내에서 각 엔티티를 고유하게 식별한다.
- 엔티티는 독립적인 의미를 가지나 애트리뷰트는 독립적인 의미를 갖지 않는다.
- 애트리뷰트는 (1) **단순 애트리뷰트**와 (2) **복합 애트리뷰트**로 나눈다.
- ER 다이어그램에서 애트리뷰트는 타원형으로 나타낸다.
- ER 다이어그램에서 기본 키에 속하는 애트리뷰트는 밑줄을 긋는다.
- ER 다이어그램에서 애트리뷰트와 엔티티 타입은 실선으로 연결한다.



#### 5.2.3.1 단순 애트리뷰트

<img width="495" alt="simple attribute" src="https://user-images.githubusercontent.com/57662010/142882389-768a2cc8-c5c7-4a97-86d4-6a068b1f9cdd.PNG" style="zoom:80%;" >

**단순 애트리뷰트(simple attribute)**: 더 이상 다른 애트리뷰트로 나눌 수 없는 애트리뷰트이다.

- ER 다이어그램에서 대부분의 애트리뷰트는 단순 애트리뷰트이다.
- ER 다이어그램에서 실선 타원으로 표현한다.



#### 5.2.3.2 복합 애트리뷰트

<img width="425" alt="composite attribute" src="https://user-images.githubusercontent.com/57662010/142879692-b274509e-a723-404c-9406-9bbb8b735d7c.PNG" style="zoom:67%;" >

**복합 애트리뷰트(composite attribute)**: 두 개 이상의 애트리뷰트로 이루어진 애트리뷰트이다.

- 동일한 엔티티 타입이나 관계 타입에 속하는 애트리뷰트들 중에서 밀접하게 연관된 것을 모아놓은 것이다.



#### 5.2.3.3 단일 값 애트리뷰트

**단일 값 애트리뷰트(single-value attribute)**: 각 엔티티마다 정확하게 하나의 값을 가지는 애트리뷰트이다.

- ER 다이어그램에서 단순 애트리뷰트와 동일하게 표현된다.
- ER 다이어그램에서 대부분의 애트리뷰트는 단일 값 애트리뷰트이다.



#### 5.2.3.4 다치 애트리뷰트

<img width="219" alt="multivalued attribute" src="https://user-images.githubusercontent.com/57662010/142880334-155cdd3d-bcc9-4858-aa58-e7bff92fc3e7.PNG">

**다치 애트리뷰트(multi-valued attribute)**: 각 엔티티마다 여러 개의 값을 가질 수 있는 애트리뷰트이다.

- ER 다이어그램에서 이중선 타원으로 표현한다.



#### 5.2.3.5 저장된 애트리뷰트

**저장된 애트리뷰트(stored attribute)**: 다른 애트리뷰트와 독립적으로 존재하는 애트리뷰트이다.

- ER 다이어그램에서 단순 애트리뷰트와 동일하게 표현된다.
- ER 다이어그램에서 대부분의 애트리뷰트는 저장된 애트리뷰트이다.
  - 예) `CHAMPION` 엔티티 타입에서 챔피언 이름, 직군번호는 다른 애트리뷰트와 독립적으로 존재한다.



#### 5.2.3.6 유도된 애트리뷰트

<img width="209" alt="derived attribute" src="https://user-images.githubusercontent.com/57662010/142880927-9e68390a-d721-4ae6-8adc-e9cf0dd343b6.PNG">

**유도된 애트리뷰트(derived attribute)**: 다른 애트리뷰트의 값으로부터 얻어진 애트리뷰트이다.

- 관계 데이터베이스에서 릴레이션의 애트리뷰트로 포함시키지 않는 것이 좋다.
  - 예) 합, 평균, 개수 등
- ER 다이어그램에서 점선 타원으로 표현한다.



### 5.2.4 약한 엔티티 타입

- 약한 엔티티 타입은 키를 형성하기에 충분한 애트리뷰트를 갖지 못한 엔티티 타입이다.
- **소유 엔티티 타입(owner entity type)** 또는 **식별 엔티티 타입(identifying entity type)**: 약한 엔티티 타입에게 키 애트리뷰트를 제공하는 엔티티 타입이다.
- **부분 키(partial key)**: 한 챔피언의 가족 이름은 모두 다르지만, 모든 챔피언의 가족을 모아놓으면 동일한 이름이 있을 수 있다. 이러한 경우가 생길 수 있는 애트리뷰트를 의미한다.
- ER 다이어그램에서 약한 엔티티 타입은 이중선 직사각형으로 표기한다.
- ER 다이어그램에서 약한 엔티티 타입의 부분 키는 점선 밑줄을 그어 표시한다.



예시

<img width="1045" alt="weak entity" src="https://user-images.githubusercontent.com/57662010/142890668-d7593257-5207-4d33-bf62-594809c35843.PNG" style="zoom: 50%;" >

- 리그 운영진들은 챔피언들의 가족에게 보험을 제공하기 위해 `CHAMPION` 엔티티 타입과 `DEPENDENT` 엔티티 타입을 `POLICY` 관계 타입으로 연결했다.
- `Depname`에 점선 밑줄을 그어 `DEPENDENT`의 부분 키를 표시했다.
- `DEPENDENT` 엔티티는 대응되는 `CHAMPION` 엔티티의 존재 여부에 의존한다.
- `CHAMPION` 엔티티 타입은 `DEPENDENT` 엔티티 타입의 소유 엔티티 타입이다.
- 강한 엔티티 타입과 약한 엔티티 타입을 연결하는 `POCLIY` 관계 타입은 이중선 다이아몬드로 표시한다.
- `POCLIY` 관계 타입은 약한 관계 타입이다.



### 5.2.5 관계와 관계 타입

- **관계**는 엔티티들 사이에 존재하는 연관이나 연결로서, 두 개 이상의 엔티티 타입들 사이의 사상이다.
- **관계 집합**은 동질의 관계들의 집합이다.
- **관계 타입**은 동질의 관계들의 틀이다.
- 관계 집합과 관계 타입을 엄격하게 구분할 필요가 없다.
- 요구사항 명세에서 흔히 동사는 ER 다이어그램에서 관계로 표현된다.
- ER 다이어그램에서 관계 타입은 다이아몬드로 표기한다.
- 관계 타입이 서로 연관시키는 엔티티 타입들과 관계 타입을 실선으로 연결한다.



예) 관계 타입 `WORK_FOR`: 챔피언은 직군에 근무한다.

<img width="596" alt="relationship type" src="https://user-images.githubusercontent.com/57662010/142892313-271b7b0b-bb7e-4def-ab9c-d616b46b084d.PNG" style="zoom: 80%;" >



#### 5.2.5.1 관계의 애트리뷰트

- 관계 타입은 관계의 특징을 기술하는 애트리뷰트들을 가질 수 있다.
- 관계 타입은 키 애트리뷰트를 갖지 않는다.



예)

<img src=".\image\5.11 관계가 갖는 애트리뷰트.PNG" alt="5.11 관계가 갖는 애트리뷰트" style="zoom:50%;" />

- `SUPPLIER` 엔티티 타입과 `PART` 엔티티 타입을 연결하는 `SUPPLIES` 관계 타입은 `Quantity` 애트리뷰트를 가진다.
- 이 수량 애트리뷰트는 어떤 공급자가 어떤 부품을 몇 개 공급하는지를 나타낸다.



#### 5.2.5.2 차수

- **차수(degree)**: 하나의 관계 타입에 대해 연결된 엔티티 타입들의 개수를 의미한다.
  - 1진 관계, 2진 관계, ... n진 관계
- 실세계에서 가장 흔한 관계는 2진 관계이다.



#### 5.2.5.3 카디날리티 비율

- **카디날리티 비율**은 한 엔티티가 참여할 수 있는 관계의 수를 나타낸다.
- 카디날리티 비율은 관계 타입에 참여하는 엔티티들의 가능한 조합을 제한한다.
- 카디날리티 비율로 관계를 1:1, 1:N, M:N으로 구분할 수 있다.
- 카디날리티에 관한 정보는 간선 위에 나타낸다.

<img src=".\image\5.14 카디날리티 비율.PNG" alt="5.14 카디날리티 비율" style="zoom: 33%;" />

- 1:1 관계: E1의 각 엔티티가 정확하게 E2의 한 엔티티와 연관되고, E2의 각 엔티티가 정확하게 E1의 한 엔티티와 연관되는 관계이다.
  - 예) 각 챔피언은 최대 한 개의 궁극기를 가지며, 각 궁극기에 대해 최대한 한 명의 챔피언이 있다.
  - 실세계에서 가장 흔히 나타난다.
- 1:N 관계: E1의 각 엔티티가 E2의 임의의 개수의 엔티티와 연관되고, E2의 각 엔티티가 정확하게 E1의 한 엔티티와 연관되는 관계이다.
  - 예) 각 챔피언은 최대 한 개의 직군을 가지며, 각 직군에 대해 여러 명의 챔피언이 있다.
- N:M 관계: 한 엔티티 타입에 속하는 임의의 개수의 엔티티가 다른 엔티티 타입에 속하는 임의의 개수의 엔티티와 연관된다.
  - 예) 각 챔피언에 대해 여러 명의 소환사가 있으며, 각 소환사에 대해 여러 명의 챔피언이 있다.



#### 5.2.5.4 카디날리티 비율의 최소값과 최대값

<img src=".\image\5.1 카디날리티의 최소값과 최대값.PNG" alt="5.1 카디날리티의 최소값과 최대값" style="zoom: 40%;" />

- 관계 타입과 엔티티 타입을 연결하는 실선 위에 `(min, max)` 형태로 표시한다.
- 어떤 관계 타입에 참여하는 각 엔티티 타입에 대하여, 이 엔티티 타입 내의 각 엔티티는 적어도 `min`번, 최대 `max` 번 관계에 참여한다.
- `min=0`은 어떤 엔티티가 반드시 관계에 참여해야 할 필요가 없음을 의미한다.
- `max-*`은 어떤 엔티티가 관계에 임의의 수만큼 참여할 수 있음을 의미한다.



#### 5.2.5.5 역할

- **역할(role)**은 관계 타입의 의미를 명확히 하기 위해 사용된다.
- 하나의 관계 타입에 하나의 엔티티 타입이 여러 번 나타나는 경우 반드시 역할을 표기해야 한다.
- 관계 타입의 간선 위에 역할을 표시한다.



예)

<img src=".\image\5.18 역할.PNG" alt="5.18 역할" style="zoom: 40%;" />

- 1명의 직원은 상사로서 N명의 직원을 관리한다.



#### 5.2.5.6 전체 참여와 부분 참여

참여 제약조건은 전체 참여와 부분 참여로 구분한다.

- **전체 참여**: 어떤 관계에 엔티티 타입 E1의 모든 엔티티들이 관계 타입 R에 의해서 어떤 엔티티 타입 E2의 어떤 엔티티와 연관되는 것을 의미한다.
- **부분 참여**: 어떤 관계에 엔티티 타입 E1의 일부 엔티티만 참여하는 것을 의미한다.
- 약한 엔티티 타입은 항상 관계에 전체 참여한다.
- ER 다이어그램에서 전체 참여는 이중 실선으로 표시한다.
- 카디날리티 비율과 함께 참여 제약조건은 관계에 대한 중요한 제약조건이다.



예)

<img src=".\image\5.19 전체 참여와 부분 참여.PNG" alt="5.19 전체 참여와 부분 참여" style="zoom:50%;" />

- 어떤 직원은 부서를 관리한다.
- 모든 부서는 어떤 직원에 의해 관리된다.



#### 5.2.5.7 다중 관계

- **다중 관계**: 엔티티 타입 사이에 두 개 이상의 관계 타입이 존재할 수 있다.



예)

<img src=".\image\5.20 다중 관계.PNG" alt="5.20 다중 관계" style="zoom:45%;" />

- 어떤 사원 한 명은 프로젝트 하나를 관리한다.
- 각 사원은 어떤 프로젝트에서 일한다.



#### 5.2.5.8 순환적 관계

- **순환적 관계**: 하나의 엔티티 타입이 동일한 관계 타입에 두 번 이상 참여하는 것이다.



예)

<img src=".\image\5.21 순환적 관계.PNG" alt="5.21 순환적 관계" style="zoom:40%;" />

- 어떤 부품은 다른 부품들이 한 개 이상 모여서 구성될 수 있다.



### 5.2.6 ER 스키마를 작성하기 위한 지침

- 엔티티는 키 애트리뷰트 이외에 설명 정보를 추가로 가진다.
- 다치 애트리뷰트는 엔티티로 분류한다.
- 애트리뷰트들이 직접적으로 설명하는 엔티티에 애트리뷰트들을 붙인다.
- 가능한 한 복합 식별자를 피한다.
- 관계는 일반적으로 독자적으로 존재할 수 었으나 엔티티 타입과 관계 타입을 절대적으로 구분하는 것은 어렵다.



### 5.2.7 데이터베이스 설계 과정

- (1) 응용의 요구사항을 수집하고 기술한다.
- (2) 응용과 연관이 있는 엔티티 타입들을 식별한다.
- (3) 응용과 연관이 있는 관계 타입들을 식별한다.
- (4) 관계가 1:1, 1:N, M:N 중 어느 것에 해당하는지 결정한다,
- (5) 엔티티 타입과 관계 타입들에 필요한 애트리뷰트들을 식별하고, 각 애트리뷰트가 가질 수 있는 값들의 집합을 식별한다.
- (6) 엔티티 타입들을 위한 기본 키를 식별한다.
- (7) ER 스키마 다이어그램 응용에 대한 요구사항과 부합되는지 검사한다.
- (8) ER 스키마 다이어그램을 DBMS에서 사용되는 데이터베이스 모델로 변환한다.



## 5.4 논리적 설계: ER 스키마를 관계 모델의 릴레이션으로 사상

관계 DBMS라면, 논리적 설계 단계에서는 ER 스키마를 관계 데이터 모델의 릴레이션들로 사상한다.

- ER 스키마에는 엔티티 타입과 관계 타입이 존재하지만, 관계 데이터베이스에는 이 둘을 구분하지 않고 릴레이션들만 있다.
- 릴레이션으로 사상할 대상에 따라 사상하는 방법이 달라진다.
  - 엔티티 타입인지 또는 관계 타입인지
  - 엔티티 타입이라면, 정규 엔티티 타입인지 또는 약한 엔티티 타입인지
  - 관계 타입이라면, 2진 관계 타입인지 3진 이상의 관계 타입인지
  - 애트리뷰트가 단일 값 애트리뷰인지 다치 애트리뷰트인지
- ER 모델을 릴레이션으로 사상하는 알고리즘은 7개의 단계로 이루어진다.

<img src=".\image\5.4 사상.PNG" alt="5.4 사상" style="zoom:60%;" />



### 5.4.1 ER-릴레이션 사상 알고리즘

#### 5.4.1.1 단계1: 정규 엔티티 타입과 단일 값 애트리뷰트

<img src=".\image\5.44 사상 단계 1.PNG" alt="5.44 사상 단계 1" style="zoom:50%;" />

- ER 스키마의 각 정규 엔티티 타입 E에 대해 하나의 릴레이션 R을 생성한다.
- 엔티티 타입 E의 애트리뷰트들을 릴레이션 R에 모두 포함시킨다.
- 엔티티 타입 E에서 복합 애트리뷰트는 그 복합 애트리뷰트를 구성하는 애트리뷰트들만 릴레이션 R에 포함시킨다.
- 엔티티 타입 E의 기본 키가 릴레이션 R의 기본 키가 된다.



#### 5.4.1.2 단계2: 약한 엔티티 타입과 단일 값 애트리뷰트

<img src=".\image\5.45 사상 단계2.PNG" alt="5.45 사상 단계2" style="zoom:50%;" />

- ER 스키마에서 소유 엔티티 타입 E를 갖는 각 약한 엔티티 타입 W에 대하여 릴레이션 R을 생성한다.
- 약한 엔티티 타입 W에 있는 모든 단순 애트리뷰트들 릴레이션 R에 포함시킨다.
- 소유 엔티티 타입에 해당하는 릴레이션의 기본 키를 약한 엔티티 타입에 해당하는 릴레이션에 외래키로 포함시킨다.
- 약한 엔티티 타입에 해당하는 릴레이션 R의 기본 키는 약한 엔티티 타입의 부분 키와 소유 엔티티 타입에 해당하는 릴레이션을 참조하는 외래 키의 조합으로 이루어진다.



#### 5.4.1.3 단계3: 2진 1:1 관계 타입

<img src=".\image\5.46 사상 단계3_1.PNG" alt="5.46 사상 단계3_1" style="zoom:50%;" />

<img src=".\image\5.46 사상 단계3_2.PNG" alt="5.46 사상 단계3_2" style="zoom:50%;" />

- ER 스키마의 각 2진 1:1 관계 타입 R에 대하여, R에 참여하는 엔티티 타입에 대응되는 릴레이션 S와 T를 찾는다.
- 방법 (1) 릴레이션 S와 T 중에서 한 릴레이션을 택한다. 릴레이션 S를 선택했다면 릴레이션 T의 기본 키를 릴레이션 S에 외래 키로 포함시킨다.
- 방법 (2) 릴레이션 S와 T 중에서 관계 타입에 완전하게 참여하는 릴레이션을 릴레이션 S의 역할을 하는 릴레이션으로 선택한다.
- 방법 (3) 관계 타입 R이 가지고 있는 모든 단순 애트리뷰트(복합 애트리뷰트를 갖고 있는 경우, 복합 애트리뷰트를 구성하는 단순 애트리뷰트)들을 릴레이션 S에 대응되는 릴레이션에 포함시킨다.
- 방법(4) 두 엔티티 타입이 관계 타입 R에 완전하게 참여할 때는 두 엔티티 타입과 관계 타입을 하나의 릴레이션으로 합치는 방법도 가능한다.



#### 5.4.1.4 단계4: 정규 2진 1:N 관계 타입

<img src=".\image\5.47 사상 단계4.PNG" alt="5.47 사상 단계4" style="zoom:65%;" />

- 정규 2진 1:N 관계 타입 R에 대하여, N측의 참여 엔티티 타입에 대응되는 릴레이션 S를 찾는다.
- 방법 (1) 관계 타입 R에 참여하는 1측의 엔티티 타입에 대응되는 릴레이션 T를 릴레이션 S에 외래 키로 포함시킨다.
- 릴레이션 S의 기본 키를 릴레이션 T에 외래 키로 포함시키면 애트리뷰트에 값들의 집합이 들어가거나 정보의 중복이 많이 발생한다.
- 관계 타입 R이 가지고 있는 모든 단순 애트리뷰트(복합 애트리뷰트를 갖고 있는 경우, 복합 애트리뷰트를 구성하는 단순 애트리뷰트)들을 S에 대응되는 릴레이션에 포함시킨다.



#### 5.4.1.5 단계5: 2진 M:N 관계 타입

<img src=".\image\5.48 사상 단계5.PNG" alt="5.48 사상 단계5" style="zoom:50%;" />

- 2진 M:N 관계 타입 R에 대해서는 릴레이션 R을 생성한다.
- 참여 엔티티 타입에 해당하는 릴레이션들의 기본 키를 릴레이션 R에 외래 키로 포함시키고, 이들의 조합이 릴레이션 R의 기본 키가 된다.
- 관계 타입 R이 가지고 있는 모든 단순 애트리뷰트(복합 애트리뷰트를 갖고 있는 경우, 복합 애트리뷰트를 구성하는 단순 애트리뷰트)들을 릴레이션 R에 포함시킨다.



#### 5.4.1.6 단계6: 3진 이상의 관계 타입

<img src=".\image\5.49 사상 단계6.PNG" alt="5.49 사상 단계6" style="zoom:50%;" />

- 3진 이상의 각 관계 타입 R에 대하여 릴레이션 R을 생성한다.
- 관계 타입 R에 참여하는 모든 엔티티 타입에 대응되는 릴레이션들의 기본 키를 릴레이션 R에 외래 키로 포함시킨다.
- 관계 타입 R이 가지고 있는 모든 단순 애트리뷰트(복합 애트리뷰트를 갖고 있는 경우, 복합 애트리뷰트를 구성하는 단순 애트리뷰트)들을 릴레이션 R에 포함시킨다.
- 일반적으로 외래 키들의 조합이 릴레이션 R의 기본 키가 된다.
- 관계 타입 R에 참여하는 엔티티 타입들의 카디날리티가 1:N:N이면 카디날리티가 1인 릴레이션의 기본 키를 참조하는 외래 키를 제외한 나머지 외래 키들의 조합이 릴레이션 R의 기본 키가 된다.



#### 5.4.1.7 단계7: 다치 애트리뷰트

<img src=".\image\5.50 사상 단계7.PNG" alt="5.50 사상 단계7" style="zoom:50%;" />

- 각 다치 애트리뷰트에 대하여 릴레이션 R을 생성한다.
- 다치 애트리뷰트에 해당하는 애트리뷰트를 릴레이션 R에 포함시키고, 다치 애트리뷰트를 애트리뷰트로 갖는 엔티티 타입이나 관계 타입에 해당하는 릴레이션의 기본 키를 릴레이션 R에 외래 키로 포함시킨다.
- 릴레이션 R의 기본 키는 다치 애트리뷰트와 외래 키의 조합이다.



ER 개념과 데이터베이스 개념은 다음과 같이 대응된다.

| ER 개념       | 데이터베이스 |
| ------------- | ------------ |
| ER 다이어그램 | 데이터베이스 |
| 엔티티        | 릴레이션     |
| 애트리뷰트    | 애트리뷰트   |
| 관계          | 외래 키      |

